{"version":3,"file":"main-555fd0c5.js","sources":["../../src/matrix/lib/gpu-buffer.js","../../src/matrix/js/webgpu/utils.js","../../src/matrix/js/webgpu/rainPass.js","../../src/matrix/js/webgpu/bloomPass.js","../../src/matrix/js/webgpu/palettePass.js","../../src/matrix/js/webgpu/stripePass.js","../../src/matrix/js/webgpu/imagePass.js","../../src/matrix/js/webgpu/mirrorPass.js","../../src/matrix/js/webgpu/endPass.js","../../src/matrix/js/webgpu/main.js"],"sourcesContent":["/**\n *\n * Meant to conform to the WGSL spec:\n *\n * https://gpuweb.github.io/gpuweb/wgsl/#alignment-and-size\n * https://gpuweb.github.io/gpuweb/wgsl/#structure-layout-rules\n *\n * TODO:\n * - Put in own repo\n * - create mocha tests\n * - Document. Provide examples of the simple constructor and from WGSL\n *\n **/\n\nconst zero = () => 0;\nconst array = (n) => () => Array(n).fill(0);\n\nconst simpleTypes = {\n\t[\"i32\"]: [4, 4, \"i32\", zero],\n\t[\"u32\"]: [4, 4, \"u32\", zero],\n\t[\"f32\"]: [4, 4, \"f32\", zero],\n\n\t[\"atomic<i32>\"]: [4, 4, \"i32\", zero],\n\t[\"atomic<u32>\"]: [4, 4, \"u32\", zero],\n\t[\"atomic<f32>\"]: [4, 4, \"f32\", zero],\n\n\t[\"vec2<i32>\"]: [8, 8, \"i32\", array(2)],\n\t[\"vec2<u32>\"]: [8, 8, \"u32\", array(2)],\n\t[\"vec2<f32>\"]: [8, 8, \"f32\", array(2)],\n\n\t[\"vec3<i32>\"]: [16, 12, \"i32\", array(3)],\n\t[\"vec3<u32>\"]: [16, 12, \"u32\", array(3)],\n\t[\"vec3<f32>\"]: [16, 12, \"f32\", array(3)],\n\n\t[\"vec4<i32>\"]: [16, 16, \"i32\", array(4)],\n\t[\"vec4<u32>\"]: [16, 16, \"u32\", array(4)],\n\t[\"vec4<f32>\"]: [16, 16, \"f32\", array(4)],\n\n\t[\"mat2x2<f32>\"]: [8, 16, \"f32\", array(2 * 2)],\n\t[\"mat3x2<f32>\"]: [8, 24, \"f32\", array(3 * 2)],\n\t[\"mat4x2<f32>\"]: [8, 32, \"f32\", array(4 * 2)],\n\t[\"mat2x3<f32>\"]: [16, 32, \"f32\", array(2 * 3)],\n\t[\"mat3x3<f32>\"]: [16, 48, \"f32\", array(3 * 3)],\n\t[\"mat4x3<f32>\"]: [16, 64, \"f32\", array(4 * 3)],\n\t[\"mat2x4<f32>\"]: [16, 32, \"f32\", array(2 * 4)],\n\t[\"mat3x4<f32>\"]: [16, 48, \"f32\", array(3 * 4)],\n\t[\"mat4x4<f32>\"]: [16, 64, \"f32\", array(4 * 4)],\n};\n\nconst getTypeData = (type, attributes, otherStructLayouts) => {\n\ttype = type.replaceAll(/\\s/g, \"\");\n\tif (simpleTypes[type] != null) {\n\t\tlet [align, size, baseType, defaultValue] = simpleTypes[type];\n\t\tif (attributes.align != null) {\n\t\t\talign = parseInt(attributes.align);\n\t\t}\n\t\tif (attributes.size != null) {\n\t\t\tsize = parseInt(attributes.size);\n\t\t}\n\t\treturn {\n\t\t\tbaseType,\n\t\t\talign,\n\t\t\tsize,\n\t\t\tdefaultValue,\n\t\t};\n\t} else if (type in otherStructLayouts) {\n\t\tconst innerLayout = otherStructLayouts[type];\n\t\tlet { align, size } = innerLayout;\n\t\tif (attributes.align != null) {\n\t\t\talign = parseInt(attributes.align);\n\t\t}\n\t\tif (attributes.size != null) {\n\t\t\tsize = parseInt(attributes.size);\n\t\t}\n\t\treturn {\n\t\t\tisStruct: true,\n\t\t\tinnerLayout,\n\t\t\tsize,\n\t\t\talign,\n\t\t\tdefaultValue: () => makeDataForLayout(otherStructLayouts, innerLayout),\n\t\t};\n\t} else if (type.startsWith(\"array<\")) {\n\t\tconst arrayMatch = type.match(/array<(.*?),?(\\d+)?>$/);\n\t\tconst [_, innerType, fixedSize] = arrayMatch;\n\t\tif (innerType == null) {\n\t\t\treturn null;\n\t\t}\n\t\tconst elementTypeData = getTypeData(innerType, [], otherStructLayouts);\n\n\t\tconst mult = parseInt(fixedSize ?? \"0\");\n\t\tconst align = elementTypeData.align;\n\t\tlet stride = elementTypeData.size;\n\t\tif (attributes.stride != null) {\n\t\t\tstride = parseInt(attributes.stride);\n\t\t}\n\t\tconst size = stride * mult;\n\n\t\treturn {\n\t\t\tisArray: true,\n\t\t\tisFixedSize: mult > 0,\n\t\t\telementTypeData,\n\t\t\tmult,\n\t\t\tsize,\n\t\t\talign,\n\t\t\tstride,\n\t\t\tdefaultValue: () =>\n\t\t\t\tArray(mult)\n\t\t\t\t\t.fill()\n\t\t\t\t\t.map((_) => elementTypeData.defaultValue()),\n\t\t};\n\t} else {\n\t\tconsole.warn(`Unrecognized type ${type}.`);\n\t\treturn null;\n\t}\n};\n\nconst parseAttributes = (str) => {\n\tconst attributes = {};\n\tfor (const attr of str.split(\",\").filter((attr) => attr.length > 0)) {\n\t\tconst match = attr.match(/(\\w+)(\\((.*)\\))?/); // foo(bar)\n\t\tconst [_, identifier, __, value] = match;\n\t\tattributes[identifier] = value;\n\t}\n\treturn attributes;\n};\n\nconst parseStructLayout = (identifier, body, structLayouts) => {\n\tconst fields = [];\n\tlet byteOffset = 0;\n\tconst lines = body\n\t\t.trim()\n\t\t.split(\",\") // WGSL struct fields are currently delimited by commas...\n\t\t.filter((s) => s.length > 0)\n\t\t// ...but some commas separate elements between angle brackets, rather than between lines:\n\t\t.reduce((existingLines, line, index) => {\n\t\t\tif (index === 0) {\n\t\t\t\treturn [line];\n\t\t\t}\n\n\t\t\tconst lastLine = existingLines[index - 1];\n\t\t\tconst angleBracketBalance = lastLine.split(\"<\").length - lastLine.split(\">\").length;\n\t\t\tif (angleBracketBalance !== 0) {\n\t\t\t\texistingLines[index - 1] = `${lastLine},${line}`;\n\t\t\t} else {\n\t\t\t\texistingLines.push(line);\n\t\t\t}\n\n\t\t\treturn existingLines;\n\t\t}, []);\n\n\tfor (const line of lines) {\n\t\tconst fieldMatch = line.match(/(@(.*?))? ?(\\w+) ?: ?(@(.*?))? ?(.*)/); // @a(...) @b(...) foo : @c(...) @d(...) bar;\n\t\tconst [_, __, leftAttributes, identifier, ___, rightAttributes, type] = fieldMatch;\n\n\t\tconst typeData = getTypeData(type, parseAttributes(rightAttributes ?? \"\"), structLayouts);\n\t\tif (typeData == null) {\n\t\t\tconsole.warn(`Skipping struct ${identifier}.`);\n\t\t\treturn null;\n\t\t}\n\n\t\tbyteOffset = Math.ceil(byteOffset / typeData.align) * typeData.align;\n\t\tfields.push({\n\t\t\tattributes: parseAttributes(leftAttributes ?? \"\"),\n\t\t\tidentifier,\n\t\t\ttype,\n\t\t\t...typeData,\n\t\t\tbyteOffset,\n\t\t});\n\t\tbyteOffset += typeData.size;\n\t}\n\n\tconst minSizeInBytes = byteOffset;\n\tconst align = Math.max(...fields.map((field) => field.align));\n\tconst size = Math.ceil(minSizeInBytes / align) * align;\n\treturn { identifier, fields, size, align };\n};\n\nconst parseStructLayoutsFromShader = (wgsl) => {\n\twgsl = wgsl\n\t\t.replace(/\\s*\\/\\/.*$/gm, \"\") // remove end-of-line comments\n\t\t.replace(/\\/\\*.*?\\*\\//gms, \"\") // remove multi-line comments\n\t\t.replace(/\\s+/gm, \" \"); // convert all contiguous whitespace to single space characters\n\n\tconst structLayouts = {};\n\tconst structMatches = Array.from(wgsl.matchAll(/struct (\\w+) ?\\{(.*?)\\};/g)); // struct Foo {...}\n\n\tfor (const structMatch of structMatches) {\n\t\tconst [_, identifier, body] = structMatch;\n\t\tconst layout = parseStructLayout(identifier, body, structLayouts);\n\t\tif (layout != null) {\n\t\t\tstructLayouts[layout.identifier] = layout;\n\t\t}\n\t}\n\treturn structLayouts;\n};\n\nconst makeDataForLayout = (structLayouts, layout) => Object.fromEntries(layout.fields.map((field) => [field.identifier, field.defaultValue()]));\n\nconst writeField = (allLayouts, field, value, views, byteOffset, warnMissingFields) => {\n\tif (value == null) {\n\t\tif (warnMissingFields) {\n\t\t\tconsole.warn(`Property missing from data: ${field.identifier}`);\n\t\t}\n\t\treturn;\n\t}\n\tif (field.isArray) {\n\t\tconst count = field.isFixedSize ? field.mult : value.length;\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\twriteField(allLayouts, field.elementTypeData, value[i], views, byteOffset + field.stride * i, warnMissingFields);\n\t\t}\n\t} else if (field.isStruct) {\n\t\tfor (const innerField of field.innerLayout.fields) {\n\t\t\twriteField(allLayouts, innerField, value[innerField.identifier], views, byteOffset + field.stride * i, warnMissingFields);\n\t\t}\n\t} else {\n\t\tconst view = views[field.baseType];\n\t\tconst array = value[Symbol.iterator] == null ? [Number(value)] : value;\n\t\tview.set(array, (byteOffset + (field.byteOffset ?? 0)) / 4);\n\t}\n};\n\nconst makeGenerator = (layout, structLayouts) => {\n\tconst minSize = layout.size;\n\treturn Object.freeze({\n\t\tminSize,\n\t\tcreate: () => makeDataForLayout(structLayouts, layout),\n\t\ttoBuffer: (object, destination, warnMissingFields = false) => {\n\t\t\tif (destination == null) {\n\t\t\t\tlet size = layout.size;\n\t\t\t\tconst lastField = layout.fields[layout.fields.length - 1];\n\t\t\t\tif (lastField.isArray && lastField.identifier in object && !lastField.isFixedSize) {\n\t\t\t\t\tsize += lastField.stride * object[lastField.identifier].length;\n\t\t\t\t}\n\t\t\t\tdestination = new ArrayBuffer(size);\n\t\t\t}\n\n\t\t\tconst views = {\n\t\t\t\ti32: new Int32Array(destination),\n\t\t\t\tu32: new Uint32Array(destination),\n\t\t\t\tf32: new Float32Array(destination),\n\t\t\t};\n\n\t\t\tfor (const field of layout.fields) {\n\t\t\t\twriteField(structLayouts, field, object[field.identifier], views, 0, warnMissingFields);\n\t\t\t}\n\n\t\t\treturn destination;\n\t\t},\n\t});\n};\n\nconst byteSizeOf = (simpleType) => simpleTypes[simpleType]?.[1];\n\nconst structs = Object.freeze({\n\tfrom: (wgsl) => {\n\t\tif (typeof wgsl !== \"string\") {\n\t\t\tthrow new Error(\"Input is not a string.\");\n\t\t}\n\t\tconst structLayouts = parseStructLayoutsFromShader(wgsl);\n\t\treturn Object.fromEntries(Object.entries(structLayouts).map(([identifier, layout]) => [identifier, makeGenerator(layout, structLayouts)]));\n\t},\n});\n\nexport { structs, byteSizeOf };\n","const loadTexture = async (device, url) => {\n\tif (url == null) {\n\t\treturn device.createTexture({\n\t\t\tsize: [1, 1, 1],\n\t\t\tformat: \"rgba8unorm\",\n\t\t\tusage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,\n\t\t});\n\t}\n\n\tconst response = await fetch(url);\n\tconst data = await response.blob();\n\tconst source = await createImageBitmap(data);\n\tconst size = [source.width, source.height, 1];\n\n\tconst texture = device.createTexture({\n\t\tsize,\n\t\tformat: \"rgba8unorm\",\n\t\tusage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,\n\t});\n\n\tdevice.queue.copyExternalImageToTexture({ source, flipY: true }, { texture }, size);\n\n\treturn texture;\n};\n\nconst makeRenderTarget = (device, size, format, mipLevelCount = 1) =>\n\tdevice.createTexture({\n\t\tsize: [...size, 1],\n\t\tmipLevelCount,\n\t\tformat,\n\t\tusage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,\n\t});\n\nconst makeComputeTarget = (device, size, mipLevelCount = 1) =>\n\tdevice.createTexture({\n\t\tsize: [...size, 1],\n\t\tmipLevelCount,\n\t\tformat: \"rgba8unorm\",\n\t\tusage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST | GPUTextureUsage.STORAGE_BINDING,\n\t});\n\nconst loadShader = async (device, url) => {\n\tconst response = await fetch(url);\n\tconst code = await response.text();\n\treturn {\n\t\tcode,\n\t\tmodule: device.createShaderModule({ code }),\n\t};\n};\n\nconst makeUniformBuffer = (device, uniforms, data = null) => {\n\tconst buffer = device.createBuffer({\n\t\tsize: uniforms.minSize,\n\t\tusage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n\t\tmappedAtCreation: data != null,\n\t});\n\tif (data != null) {\n\t\tuniforms.toBuffer(data, buffer.getMappedRange());\n\t\tbuffer.unmap();\n\t}\n\treturn buffer;\n};\n\nconst make1DTexture = (device, rgbas) => {\n\tconst size = [rgbas.length];\n\tconst texture = device.createTexture({\n\t\tsize,\n\t\t// dimension: \"1d\",\n\t\tformat: \"rgba8unorm\",\n\t\tusage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,\n\t});\n\tconst data = new Uint8ClampedArray(rgbas.map((color) => color.map((f) => f * 0xff)).flat());\n\tdevice.queue.writeTexture({ texture }, data, {}, size);\n\treturn texture;\n};\n\nconst makeBindGroup = (device, pipeline, index, entries) =>\n\tdevice.createBindGroup({\n\t\tlayout: pipeline.getBindGroupLayout(index),\n\t\tentries: entries\n\t\t\t.map((resource) => (resource instanceof GPUBuffer ? { buffer: resource } : resource))\n\t\t\t.map((resource, binding) => ({\n\t\t\t\tbinding,\n\t\t\t\tresource,\n\t\t\t})),\n\t});\n\nconst makePass = (name, loaded, build, run) => ({\n\tloaded: loaded ?? Promise.resolve(),\n\tbuild: build ?? ((size, inputs) => inputs),\n\trun: (encoder, shouldRender) => {\n\t\tencoder.pushDebugGroup(`Pass \"${name}\"`);\n\t\trun?.(encoder, shouldRender);\n\t\tencoder.popDebugGroup();\n\t},\n});\n\nconst makePipeline = async (context, steps) => {\n\tsteps = steps.filter((f) => f != null).map((f) => f(context));\n\tawait Promise.all(steps.map((step) => step.loaded));\n\treturn {\n\t\tsteps,\n\t\tbuild: (canvasSize) => steps.reduce((outputs, step) => step.build(canvasSize, outputs), null),\n\t\trun: (encoder, shouldRender) => steps.forEach((step) => step.run(encoder, shouldRender)),\n\t};\n};\n\nexport { makeRenderTarget, makeComputeTarget, make1DTexture, loadTexture, loadShader, makeUniformBuffer, makePass, makePipeline, makeBindGroup };\n","import { structs } from '../../lib/gpu-buffer.js'\nimport {\n  makeRenderTarget,\n  loadTexture,\n  loadShader,\n  makeUniformBuffer,\n  makeBindGroup,\n  makePass\n} from './utils.js'\n\nconst rippleTypes = {\n  box: 0,\n  circle: 1\n}\n\nconst numVerticesPerQuad = 2 * 3\n\nconst makeConfigBuffer = (device, configUniforms, config, density, gridSize) => {\n  const configData = {\n    ...config,\n    gridSize,\n    density,\n    showDebugView: config.effect === 'none',\n    rippleType: config.rippleTypeName in rippleTypes ? rippleTypes[config.rippleTypeName] : -1,\n    slantScale: 1 / (Math.abs(Math.sin(2 * config.slant)) * (Math.sqrt(2) - 1) + 1),\n    slantVec: [Math.cos(config.slant), Math.sin(config.slant)],\n    msdfPxRange: 4\n  }\n  // console.table(configData);\n\n  return makeUniformBuffer(device, configUniforms, configData)\n}\n\nexport default ({ config, device, timeBuffer }) => {\n  const { mat4, vec3 } = glMatrix\n\n  const assets = [\n    loadTexture(device, config.glyphMSDFURL),\n    loadTexture(device, config.glintMSDFURL),\n    loadTexture(device, config.baseTextureURL, false, true),\n    loadTexture(device, config.glintTextureURL, false, true),\n    loadShader(device, 'src/matrix/shaders/wgsl/rainPass.wgsl')\n  ]\n\n  // The volumetric mode multiplies the number of columns\n  // to reach the desired density, and then overlaps them\n  const density = config.volumetric && config.effect !== 'none' ? config.density : 1\n  const gridSize = [Math.floor(config.numColumns * density), config.numColumns]\n  const numCells = gridSize[0] * gridSize[1]\n\n  // The volumetric mode requires us to create a grid of quads,\n  // rather than a single quad for our geometry\n  const numQuads = config.volumetric ? numCells : 1\n\n  const transform = mat4.create()\n  if (config.volumetric && config.isometric) {\n    mat4.rotateX(transform, transform, (Math.PI * 1) / 8)\n    mat4.rotateY(transform, transform, (Math.PI * 1) / 4)\n    mat4.translate(transform, transform, vec3.fromValues(0, 0, -1))\n    mat4.scale(transform, transform, vec3.fromValues(1, 1, 2))\n  } else {\n    mat4.translate(transform, transform, vec3.fromValues(0, 0, -1))\n  }\n  const camera = mat4.create()\n\n  // TODO: vantage points, multiple renders\n\n  // We use the different channels for different parts of the raindrop\n  const renderFormat = 'rgba8unorm'\n\n  const linearSampler = device.createSampler({\n    magFilter: 'linear',\n    minFilter: 'linear'\n  })\n\n  const renderPassConfig = {\n    colorAttachments: [\n      {\n        // view: null,\n        loadOp: 'clear',\n        storeOp: 'store'\n      },\n      {\n        // view: null,\n        loadOp: 'clear',\n        storeOp: 'store'\n      }\n    ]\n  }\n\n  let configBuffer\n  let sceneUniforms\n  let sceneBuffer\n  let introPipeline\n  let computePipeline\n  let renderPipeline\n  let introBindGroup\n  let computeBindGroup\n  let renderBindGroup\n  let output\n  let highPassOutput\n\n  const loaded = (async () => {\n    const [glyphMSDFTexture, glintMSDFTexture, baseTexture, glintTexture, rainShader] =\n      await Promise.all(assets)\n\n    const rainShaderUniforms = structs.from(rainShader.code)\n    configBuffer = makeConfigBuffer(device, rainShaderUniforms.Config, config, density, gridSize)\n\n    const introCellsBuffer = device.createBuffer({\n      size: gridSize[0] * rainShaderUniforms.IntroCell.minSize,\n      usage: GPUBufferUsage.STORAGE\n    })\n\n    const cellsBuffer = device.createBuffer({\n      size: numCells * rainShaderUniforms.Cell.minSize,\n      usage: GPUBufferUsage.STORAGE\n    })\n\n    sceneUniforms = rainShaderUniforms.Scene\n    sceneBuffer = makeUniformBuffer(device, sceneUniforms)\n\n    const additiveBlendComponent = {\n      operation: 'add',\n      srcFactor: 'one',\n      dstFactor: 'one'\n    }\n\n    ;[introPipeline, computePipeline, renderPipeline] = await Promise.all([\n      device.createComputePipelineAsync({\n        layout: 'auto',\n        compute: {\n          module: rainShader.module,\n          entryPoint: 'computeIntro'\n        }\n      }),\n\n      device.createComputePipelineAsync({\n        layout: 'auto',\n        compute: {\n          module: rainShader.module,\n          entryPoint: 'computeMain'\n        }\n      }),\n\n      device.createRenderPipelineAsync({\n        layout: 'auto',\n        vertex: {\n          module: rainShader.module,\n          entryPoint: 'vertMain'\n        },\n        fragment: {\n          module: rainShader.module,\n          entryPoint: 'fragMain',\n          targets: [\n            {\n              format: renderFormat,\n              blend: {\n                color: additiveBlendComponent,\n                alpha: additiveBlendComponent\n              }\n            },\n            {\n              format: renderFormat,\n              blend: {\n                color: additiveBlendComponent,\n                alpha: additiveBlendComponent\n              }\n            }\n          ]\n        }\n      })\n    ])\n\n    introBindGroup = makeBindGroup(device, introPipeline, 0, [\n      configBuffer,\n      timeBuffer,\n      introCellsBuffer\n    ])\n    computeBindGroup = makeBindGroup(device, computePipeline, 0, [\n      configBuffer,\n      timeBuffer,\n      cellsBuffer,\n      introCellsBuffer\n    ])\n    renderBindGroup = makeBindGroup(device, renderPipeline, 0, [\n      configBuffer,\n      timeBuffer,\n      sceneBuffer,\n      linearSampler,\n      glyphMSDFTexture.createView(),\n      glintMSDFTexture.createView(),\n      baseTexture.createView(),\n      glintTexture.createView(),\n      cellsBuffer\n    ])\n  })()\n\n  const build = (size) => {\n    // Update scene buffer: camera and transform math for the volumetric mode\n    const aspectRatio = size[0] / size[1]\n    if (config.volumetric && config.isometric) {\n      if (aspectRatio > 1) {\n        mat4.orthoZO(camera, -1.5 * aspectRatio, 1.5 * aspectRatio, -1.5, 1.5, -1000, 1000)\n      } else {\n        mat4.orthoZO(camera, -1.5, 1.5, -1.5 / aspectRatio, 1.5 / aspectRatio, -1000, 1000)\n      }\n    } else {\n      mat4.perspectiveZO(camera, (Math.PI / 180) * 90, aspectRatio, 0.0001, 1000)\n    }\n    const screenSize = aspectRatio > 1 ? [1, aspectRatio] : [1 / aspectRatio, 1]\n    device.queue.writeBuffer(\n      sceneBuffer,\n      0,\n      sceneUniforms.toBuffer({ screenSize, camera, transform })\n    )\n\n    // Update\n    output?.destroy()\n    output = makeRenderTarget(device, size, renderFormat)\n\n    highPassOutput?.destroy()\n    highPassOutput = makeRenderTarget(device, size, renderFormat)\n\n    return {\n      primary: output,\n      highPass: highPassOutput\n    }\n  }\n\n  const run = (encoder, shouldRender) => {\n    // We render the code into an Target using MSDFs: https://github.com/Chlumsky/msdfgen\n\n    const introPass = encoder.beginComputePass()\n    introPass.setPipeline(introPipeline)\n    introPass.setBindGroup(0, introBindGroup)\n    introPass.dispatchWorkgroups(Math.ceil(gridSize[0] / 32), 1, 1)\n    introPass.end()\n\n    const computePass = encoder.beginComputePass()\n    computePass.setPipeline(computePipeline)\n    computePass.setBindGroup(0, computeBindGroup)\n    computePass.dispatchWorkgroups(Math.ceil(gridSize[0] / 32), gridSize[1], 1)\n    computePass.end()\n\n    if (shouldRender) {\n      renderPassConfig.colorAttachments[0].view = output.createView()\n      renderPassConfig.colorAttachments[1].view = highPassOutput.createView()\n      const renderPass = encoder.beginRenderPass(renderPassConfig)\n      renderPass.setPipeline(renderPipeline)\n      renderPass.setBindGroup(0, renderBindGroup)\n      renderPass.draw(numVerticesPerQuad * numQuads, 1, 0, 0)\n      renderPass.end()\n    }\n  }\n\n  return makePass('Rain', loaded, build, run)\n}\n","import { structs } from '../../lib/gpu-buffer.js'\nimport {\n  makeComputeTarget,\n  loadShader,\n  makeUniformBuffer,\n  makeBindGroup,\n  makePass\n} from './utils.js'\n\n// const makePyramid = makeComputeTarget;\n\n// const destroyPyramid = (pyramid) => pyramid?.destroy();\n\n// const makePyramidLevelView = (pyramid, level) =>\n// \tpyramid.createView({\n// \t\tbaseMipLevel: level,\n// \t\tmipLevelCount: 1,\n// \t\tdimension: \"2d\",\n// \t});\n\n// const makePyramidViews = (pyramid) => [pyramid.createView()];\n\nconst makePyramid = (device, size, pyramidHeight) =>\n  Array(pyramidHeight)\n    .fill()\n    .map((_, index) =>\n      makeComputeTarget(\n        device,\n        size.map((x) => Math.floor(x * 2 ** -index))\n      )\n    )\n\nconst destroyPyramid = (pyramid) => pyramid?.forEach((texture) => texture.destroy())\n\nconst makePyramidLevelView = (pyramid, level) => pyramid[level].createView()\n\nconst makePyramidViews = (pyramid) => pyramid.map((tex) => tex.createView())\n\n// The bloom pass is basically an added blur of the rain pass's high-pass output.\n// The blur approximation is the sum of a pyramid of downscaled, blurred textures.\n\nexport default ({ config, device }) => {\n  const pyramidHeight = 4\n  const bloomSize = config.bloomSize\n  const bloomStrength = config.bloomStrength\n  const bloomRadius = 2 // Looks better with more, but is more costly\n\n  const enabled = bloomSize > 0 && bloomStrength > 0\n\n  // If there's no bloom to apply, return a no-op pass with an empty bloom texture\n  if (!enabled) {\n    const emptyTexture = makeComputeTarget(device, [1, 1])\n    return makePass('No Bloom', null, (size, inputs) => ({ ...inputs, bloom: emptyTexture }))\n  }\n\n  const assets = [\n    loadShader(device, 'src/matrix/shaders/wgsl/bloomBlur.wgsl'),\n    loadShader(device, 'shaders/wgsl/bloomCombine.wgsl')\n  ]\n\n  const linearSampler = device.createSampler({\n    magFilter: 'linear',\n    minFilter: 'linear'\n  })\n\n  // The blur pipeline applies a blur in one direction; it's applied horizontally\n  // to the first image pyramid, and then vertically to the second image pyramid.\n  let blurPipeline\n  let hBlurPyramid\n  let vBlurPyramid\n  let hBlurBuffer\n  let vBlurBuffer\n  let hBlurBindGroups\n  let vBlurBindGroups\n\n  // The combine pipeline blends the last image pyramid's layers into the output.\n  let combinePipeline\n  let combineBuffer\n  let combineBindGroup\n  let output\n  let scaledScreenSize\n\n  const loaded = (async () => {\n    const [blurShader, combineShader] = await Promise.all(assets)\n\n    ;[blurPipeline, combinePipeline] = await Promise.all([\n      device.createComputePipeline({\n        layout: 'auto',\n        compute: {\n          module: blurShader.module,\n          entryPoint: 'computeMain'\n        }\n      }),\n\n      device.createComputePipeline({\n        layout: 'auto',\n        compute: {\n          module: combineShader.module,\n          entryPoint: 'computeMain'\n        }\n      })\n    ])\n\n    const blurUniforms = structs.from(blurShader.code).Config\n    hBlurBuffer = makeUniformBuffer(device, blurUniforms, { bloomRadius, direction: [1, 0] })\n    vBlurBuffer = makeUniformBuffer(device, blurUniforms, { bloomRadius, direction: [0, 1] })\n\n    const combineUniforms = structs.from(combineShader.code).Config\n    combineBuffer = makeUniformBuffer(device, combineUniforms, { pyramidHeight, bloomStrength })\n  })()\n\n  const build = (screenSize, inputs) => {\n    // Since the bloom is blurry, we downscale everything\n    scaledScreenSize = screenSize.map((x) => Math.floor(x * bloomSize))\n\n    destroyPyramid(hBlurPyramid)\n    hBlurPyramid = makePyramid(device, scaledScreenSize, pyramidHeight)\n\n    destroyPyramid(vBlurPyramid)\n    vBlurPyramid = makePyramid(device, scaledScreenSize, pyramidHeight)\n\n    output?.destroy()\n    output = makeComputeTarget(device, scaledScreenSize)\n\n    hBlurBindGroups = []\n    vBlurBindGroups = []\n\n    // The first pyramid's level 1 texture is the input texture blurred.\n    // The subsequent levels of the pyramid are the preceding level blurred.\n    let srcView = inputs.highPass.createView()\n    for (let i = 0; i < pyramidHeight; i++) {\n      const hBlurPyramidView = makePyramidLevelView(hBlurPyramid, i)\n      const vBlurPyramidView = makePyramidLevelView(vBlurPyramid, i)\n      hBlurBindGroups[i] = makeBindGroup(device, blurPipeline, 0, [\n        hBlurBuffer,\n        linearSampler,\n        srcView,\n        hBlurPyramidView\n      ])\n      vBlurBindGroups[i] = makeBindGroup(device, blurPipeline, 0, [\n        vBlurBuffer,\n        linearSampler,\n        hBlurPyramidView,\n        vBlurPyramidView\n      ])\n      srcView = hBlurPyramidView\n    }\n\n    combineBindGroup = makeBindGroup(device, combinePipeline, 0, [\n      combineBuffer,\n      linearSampler,\n      ...makePyramidViews(vBlurPyramid),\n      output.createView()\n    ])\n\n    return {\n      ...inputs,\n      bloom: output\n    }\n  }\n\n  const run = (encoder, shouldRender) => {\n    if (!shouldRender) {\n      return\n    }\n\n    const computePass = encoder.beginComputePass()\n\n    computePass.setPipeline(blurPipeline)\n    for (let i = 0; i < pyramidHeight; i++) {\n      const dispatchSize = [\n        Math.ceil(Math.floor(scaledScreenSize[0] * 2 ** -i) / 32),\n        Math.floor(Math.floor(scaledScreenSize[1] * 2 ** -i)),\n        1\n      ]\n      computePass.setBindGroup(0, hBlurBindGroups[i])\n      computePass.dispatchWorkgroups(...dispatchSize)\n      computePass.setBindGroup(0, vBlurBindGroups[i])\n      computePass.dispatchWorkgroups(...dispatchSize)\n    }\n\n    computePass.setPipeline(combinePipeline)\n    computePass.setBindGroup(0, combineBindGroup)\n    computePass.dispatchWorkgroups(Math.ceil(scaledScreenSize[0] / 32), scaledScreenSize[1], 1)\n\n    computePass.end()\n  }\n\n  return makePass('Bloom', loaded, build, run)\n}\n","import colorToRGB from '../colorToRGB.js'\nimport { structs } from '../../lib/gpu-buffer.js'\nimport {\n  loadShader,\n  makeUniformBuffer,\n  makeBindGroup,\n  makeComputeTarget,\n  makePass\n} from './utils.js'\n\n// Maps the brightness of the rendered rain and bloom to colors\n// in a linear gradient buffer generated from the passed-in color sequence\n\n// This shader introduces noise into the renders, to avoid banding\n\nconst makePalette = (device, paletteUniforms, entries) => {\n  const PALETTE_SIZE = 512\n  const paletteColors = Array(PALETTE_SIZE)\n\n  // Convert HSL gradient into sorted RGB gradient, capping the ends\n  const sortedEntries = entries\n    .slice()\n    .sort((e1, e2) => e1.at - e2.at)\n    .map((entry) => ({\n      rgb: colorToRGB(entry.color),\n      arrayIndex: Math.floor(Math.max(Math.min(1, entry.at), 0) * (PALETTE_SIZE - 1))\n    }))\n  sortedEntries.unshift({ rgb: sortedEntries[0].rgb, arrayIndex: 0 })\n  sortedEntries.push({\n    rgb: sortedEntries[sortedEntries.length - 1].rgb,\n    arrayIndex: PALETTE_SIZE - 1\n  })\n\n  // Interpolate between the sorted RGB entries to generate\n  // the palette texture data\n  sortedEntries.forEach((entry, index) => {\n    paletteColors[entry.arrayIndex] = entry.rgb.slice()\n    if (index + 1 < sortedEntries.length) {\n      const nextEntry = sortedEntries[index + 1]\n      const diff = nextEntry.arrayIndex - entry.arrayIndex\n      for (let i = 0; i < diff; i++) {\n        const ratio = i / diff\n        paletteColors[entry.arrayIndex + i] = [\n          entry.rgb[0] * (1 - ratio) + nextEntry.rgb[0] * ratio,\n          entry.rgb[1] * (1 - ratio) + nextEntry.rgb[1] * ratio,\n          entry.rgb[2] * (1 - ratio) + nextEntry.rgb[2] * ratio\n        ]\n      }\n    }\n  })\n\n  // TODO: try using gpu-uniforms\n\n  const paletteBuffer = device.createBuffer({\n    size: (3 + 1) * PALETTE_SIZE * Float32Array.BYTES_PER_ELEMENT,\n    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    mappedAtCreation: true\n  })\n\n  const view = new Float32Array(paletteBuffer.getMappedRange())\n  for (let i = 0; i < paletteColors.length; i++) {\n    view.set(paletteColors[i], (3 + 1) * i)\n  }\n\n  paletteBuffer.unmap()\n\n  return paletteBuffer\n}\n\n// The rendered texture's values are mapped to colors in a palette texture.\n// A little noise is introduced, to hide the banding that appears\n// in subtle gradients. The noise is also time-driven, so its grain\n// won't persist across subsequent frames. This is a safe trick\n// in screen space.\n\nexport default ({ config, device, timeBuffer }) => {\n  const linearSampler = device.createSampler({\n    magFilter: 'linear',\n    minFilter: 'linear'\n  })\n\n  let computePipeline\n  let configBuffer\n  let paletteBuffer\n  let computeBindGroup\n  let output\n  let screenSize\n\n  const assets = [loadShader(device, 'src/matrix/shaders/wgsl/palettePass.wgsl')]\n\n  const loaded = (async () => {\n    const [paletteShader] = await Promise.all(assets)\n\n    computePipeline = await device.createComputePipelineAsync({\n      layout: 'auto',\n      compute: {\n        module: paletteShader.module,\n        entryPoint: 'computeMain'\n      }\n    })\n\n    const paletteShaderUniforms = structs.from(paletteShader.code)\n    const configUniforms = paletteShaderUniforms.Config\n    configBuffer = makeUniformBuffer(device, configUniforms, {\n      ditherMagnitude: config.ditherMagnitude,\n      backgroundColor: colorToRGB(config.backgroundColor),\n      cursorColor: colorToRGB(config.cursorColor),\n      glintColor: colorToRGB(config.glintColor),\n      cursorIntensity: config.cursorIntensity,\n      glintIntensity: config.glintIntensity\n    })\n\n    const paletteUniforms = paletteShaderUniforms.Palette\n    paletteBuffer = makePalette(device, paletteUniforms, config.palette)\n  })()\n\n  const build = (size, inputs) => {\n    output?.destroy()\n    output = makeComputeTarget(device, size)\n    screenSize = size\n    computeBindGroup = makeBindGroup(device, computePipeline, 0, [\n      configBuffer,\n      paletteBuffer,\n      timeBuffer,\n      linearSampler,\n      inputs.primary.createView(),\n      inputs.bloom.createView(),\n      output.createView()\n    ])\n    return { primary: output }\n  }\n\n  const run = (encoder, shouldRender) => {\n    if (!shouldRender) {\n      return\n    }\n\n    const computePass = encoder.beginComputePass()\n    computePass.setPipeline(computePipeline)\n    computePass.setBindGroup(0, computeBindGroup)\n    computePass.dispatchWorkgroups(Math.ceil(screenSize[0] / 32), screenSize[1], 1)\n    computePass.end()\n  }\n\n  return makePass('Palette', loaded, build, run)\n}\n","import colorToRGB from '../colorToRGB.js'\nimport { structs } from '../../lib/gpu-buffer.js'\nimport {\n  loadShader,\n  make1DTexture,\n  makeUniformBuffer,\n  makeBindGroup,\n  makeComputeTarget,\n  makePass\n} from './utils.js'\n\n// Multiplies the rendered rain and bloom by a 1D gradient texture\n// generated from the passed-in color sequence\n\n// This shader introduces noise into the renders, to avoid banding\n\nconst transPrideStripeColors = [\n  { space: 'rgb', values: [0.36, 0.81, 0.98] },\n  { space: 'rgb', values: [0.96, 0.66, 0.72] },\n  { space: 'rgb', values: [1.0, 1.0, 1.0] },\n  { space: 'rgb', values: [0.96, 0.66, 0.72] },\n  { space: 'rgb', values: [0.36, 0.81, 0.98] }\n]\n  .map((color) => Array(3).fill(color))\n  .flat(1)\n\nconst prideStripeColors = [\n  { space: 'rgb', values: [0.89, 0.01, 0.01] },\n  { space: 'rgb', values: [1.0, 0.55, 0.0] },\n  { space: 'rgb', values: [1.0, 0.93, 0.0] },\n  { space: 'rgb', values: [0.0, 0.5, 0.15] },\n  { space: 'rgb', values: [0.0, 0.3, 1.0] },\n  { space: 'rgb', values: [0.46, 0.03, 0.53] }\n]\n  .map((color) => Array(2).fill(color))\n  .flat(1)\n\nconst numVerticesPerQuad = 2 * 3\n\n// The rendered texture's values are mapped to colors in a palette texture.\n// A little noise is introduced, to hide the banding that appears\n// in subtle gradients. The noise is also time-driven, so its grain\n// won't persist across subsequent frames. This is a safe trick\n// in screen space.\n\nexport default ({ config, device, timeBuffer }) => {\n  // Expand and convert stripe colors into 1D texture data\n  const stripeColors =\n    'stripeColors' in config\n      ? config.stripeColors\n      : config.effect === 'pride'\n      ? prideStripeColors\n      : transPrideStripeColors\n  const stripeTex = make1DTexture(\n    device,\n    stripeColors.map((color) => [...colorToRGB(color), 1])\n  )\n\n  const linearSampler = device.createSampler({\n    magFilter: 'linear',\n    minFilter: 'linear'\n  })\n\n  let computePipeline\n  let configBuffer\n  let tex\n  let bloomTex\n  let output\n  let screenSize\n\n  const assets = [loadShader(device, 'src/matrix/shaders/wgsl/stripePass.wgsl')]\n\n  const loaded = (async () => {\n    const [stripeShader] = await Promise.all(assets)\n\n    computePipeline = await device.createComputePipelineAsync({\n      layout: 'auto',\n      compute: {\n        module: stripeShader.module,\n        entryPoint: 'computeMain'\n      }\n    })\n\n    const configUniforms = structs.from(stripeShader.code).Config\n    configBuffer = makeUniformBuffer(device, configUniforms, {\n      ditherMagnitude: config.ditherMagnitude,\n      backgroundColor: colorToRGB(config.backgroundColor),\n      cursorColor: colorToRGB(config.cursorColor),\n      glintColor: colorToRGB(config.glintColor),\n      cursorIntensity: config.cursorIntensity,\n      glintIntensity: config.glintIntensity\n    })\n  })()\n\n  const build = (size, inputs) => {\n    output?.destroy()\n    output = makeComputeTarget(device, size)\n    screenSize = size\n\n    tex = inputs.primary\n    bloomTex = inputs.bloom\n\n    return {\n      primary: output\n    }\n  }\n\n  const run = (encoder, shouldRender) => {\n    if (!shouldRender) {\n      return\n    }\n\n    const computePass = encoder.beginComputePass()\n    computePass.setPipeline(computePipeline)\n    const computeBindGroup = makeBindGroup(device, computePipeline, 0, [\n      configBuffer,\n      timeBuffer,\n      linearSampler,\n      tex.createView(),\n      bloomTex.createView(),\n      stripeTex.createView(),\n      output.createView()\n    ])\n    computePass.setBindGroup(0, computeBindGroup)\n    computePass.dispatchWorkgroups(Math.ceil(screenSize[0] / 32), screenSize[1], 1)\n    computePass.end()\n  }\n\n  return makePass('Stripe', loaded, build, run)\n}\n","import { structs } from '../../lib/gpu-buffer.js'\nimport {\n  makeComputeTarget,\n  makeUniformBuffer,\n  loadTexture,\n  loadShader,\n  makeBindGroup,\n  makePass\n} from './utils.js'\n\n// Multiplies the rendered rain and bloom by a loaded in image\n\nconst defaultBGURL =\n  'https://upload.wikimedia.org/wikipedia/commons/thumb/0/0a/Flammarion_Colored.jpg/917px-Flammarion_Colored.jpg'\n\nexport default ({ config, device }) => {\n  const bgURL = 'bgURL' in config ? config.bgURL : defaultBGURL\n  const assets = [\n    loadTexture(device, bgURL),\n    loadShader(device, 'src/matrix/shaders/wgsl/imagePass.wgsl')\n  ]\n\n  const linearSampler = device.createSampler({\n    magFilter: 'linear',\n    minFilter: 'linear'\n  })\n\n  let computePipeline\n  let configBuffer\n  let output\n  let screenSize\n  let backgroundTex\n  let computeBindGroup\n\n  const loaded = (async () => {\n    const [bgTex, imageShader] = await Promise.all(assets)\n\n    backgroundTex = bgTex\n\n    computePipeline = await device.createComputePipelineAsync({\n      layout: 'auto',\n      compute: {\n        module: imageShader.module,\n        entryPoint: 'computeMain'\n      }\n    })\n\n    const configUniforms = structs.from(imageShader.code).Config\n    configBuffer = makeUniformBuffer(device, configUniforms, { unused: 0 })\n  })()\n\n  const build = (size, inputs) => {\n    output?.destroy()\n    output = makeComputeTarget(device, size)\n    screenSize = size\n    computeBindGroup = makeBindGroup(device, computePipeline, 0, [\n      configBuffer,\n      linearSampler,\n      inputs.primary.createView(),\n      inputs.bloom.createView(),\n      backgroundTex.createView(),\n      output.createView()\n    ])\n    return { primary: output }\n  }\n\n  const run = (encoder, shouldRender) => {\n    if (!shouldRender) {\n      return\n    }\n\n    const computePass = encoder.beginComputePass()\n    computePass.setPipeline(computePipeline)\n    computePass.setBindGroup(0, computeBindGroup)\n    computePass.dispatchWorkgroups(Math.ceil(screenSize[0] / 32), screenSize[1], 1)\n    computePass.end()\n  }\n\n  return makePass('Image', loaded, build, run)\n}\n","import { structs } from '../../lib/gpu-buffer.js'\nimport {\n  makeComputeTarget,\n  makeUniformBuffer,\n  loadShader,\n  makeBindGroup,\n  makePass\n} from './utils.js'\n\nlet start\nconst numTouches = 5\nconst touches = Array(numTouches)\n  .fill()\n  .map((_) => [0, 0, -Infinity, 0])\nlet aspectRatio = 1\n\nlet index = 0\nlet touchesChanged = true\nwindow.onclick = (e) => {\n  touches[index][0] = 0 + e.clientX / e.srcElement.clientWidth\n  touches[index][1] = 1 - e.clientY / e.srcElement.clientHeight\n  touches[index][2] = (Date.now() - start) / 1000\n  index = (index + 1) % numTouches\n  touchesChanged = true\n}\n\nexport default ({ config, device, cameraTex, cameraAspectRatio, timeBuffer }) => {\n  const assets = [loadShader(device, 'src/matrix/shaders/wgsl/mirrorPass.wgsl')]\n\n  const linearSampler = device.createSampler({\n    magFilter: 'linear',\n    minFilter: 'linear'\n  })\n\n  let computePipeline\n  let configBuffer\n  let sceneUniforms\n  let sceneBuffer\n  let touchUniforms\n  let touchBuffer\n  let output\n  let screenSize\n  let computeBindGroup\n\n  const loaded = (async () => {\n    const [mirrorShader] = await Promise.all(assets)\n\n    computePipeline = await device.createComputePipelineAsync({\n      layout: 'auto',\n      compute: {\n        module: mirrorShader.module,\n        entryPoint: 'computeMain'\n      }\n    })\n\n    const mirrorShaderUniforms = structs.from(mirrorShader.code)\n\n    const configUniforms = mirrorShaderUniforms.Config\n    configBuffer = makeUniformBuffer(device, configUniforms, { unused: 0 })\n\n    sceneUniforms = mirrorShaderUniforms.Scene\n    sceneBuffer = makeUniformBuffer(device, sceneUniforms)\n\n    touchUniforms = mirrorShaderUniforms.Touches\n    touchBuffer = makeUniformBuffer(device, touchUniforms)\n  })()\n\n  const build = (size, inputs) => {\n    output?.destroy()\n    output = makeComputeTarget(device, size)\n    screenSize = size\n    aspectRatio = size[0] / size[1]\n    computeBindGroup = makeBindGroup(device, computePipeline, 0, [\n      configBuffer,\n      timeBuffer,\n      sceneBuffer,\n      touchBuffer,\n      linearSampler,\n      inputs.primary.createView(),\n      inputs.bloom.createView(),\n      cameraTex.createView(),\n      output.createView()\n    ])\n\n    const screenAspectRatio = size[0] / size[1]\n    device.queue.writeBuffer(\n      sceneBuffer,\n      0,\n      sceneUniforms.toBuffer({ screenAspectRatio, cameraAspectRatio })\n    )\n\n    return { primary: output }\n  }\n\n  const run = (encoder, shouldRender) => {\n    if (!shouldRender) {\n      return\n    }\n\n    if (touchesChanged) {\n      touchesChanged = false\n      device.queue.writeBuffer(touchBuffer, 0, touchUniforms.toBuffer({ touches }))\n    }\n\n    const computePass = encoder.beginComputePass()\n    computePass.setPipeline(computePipeline)\n    computePass.setBindGroup(0, computeBindGroup)\n    computePass.dispatchWorkgroups(Math.ceil(screenSize[0] / 32), screenSize[1], 1)\n    computePass.end()\n  }\n\n  start = Date.now()\n\n  return makePass('Mirror', loaded, build, run)\n}\n","import { loadShader, makeBindGroup, makePass } from './utils.js'\n\n// Eventually, WebGPU will allow the output of the final pass in the pipeline to be copied to the canvas texture.\n// Until then, this render pass does the job.\n\nconst numVerticesPerQuad = 2 * 3\n\nexport default ({ device, canvasFormat, canvasContext }) => {\n  const nearestSampler = device.createSampler()\n\n  const renderPassConfig = {\n    colorAttachments: [\n      {\n        // view: null,\n        loadOp: 'clear',\n        storeOp: 'store'\n      }\n    ]\n  }\n\n  let renderPipeline\n  let renderBindGroup\n\n  const assets = [loadShader(device, 'src/matrix/shaders/wgsl/endPass.wgsl')]\n\n  const loaded = (async () => {\n    const [imageShader] = await Promise.all(assets)\n\n    renderPipeline = await device.createRenderPipelineAsync({\n      layout: 'auto',\n      vertex: {\n        module: imageShader.module,\n        entryPoint: 'vertMain'\n      },\n      fragment: {\n        module: imageShader.module,\n        entryPoint: 'fragMain',\n        targets: [\n          {\n            format: canvasFormat\n          }\n        ]\n      }\n    })\n  })()\n\n  const build = (size, inputs) => {\n    renderBindGroup = makeBindGroup(device, renderPipeline, 0, [\n      nearestSampler,\n      inputs.primary.createView()\n    ])\n    return null\n  }\n\n  const run = (encoder, shouldRender) => {\n    if (!shouldRender) {\n      return\n    }\n\n    renderPassConfig.colorAttachments[0].view = canvasContext.getCurrentTexture().createView()\n    const renderPass = encoder.beginRenderPass(renderPassConfig)\n    renderPass.setPipeline(renderPipeline)\n    renderPass.setBindGroup(0, renderBindGroup)\n    renderPass.draw(numVerticesPerQuad, 1, 0, 0)\n    renderPass.end()\n  }\n\n  return makePass('End', loaded, build, run)\n}\n","import { structs } from \"../../lib/gpu-buffer.js\";\nimport { makeUniformBuffer, makePipeline } from \"./utils.js\";\n\nimport makeRain from \"./rainPass.js\";\nimport makeBloomPass from \"./bloomPass.js\";\nimport makePalettePass from \"./palettePass.js\";\nimport makeStripePass from \"./stripePass.js\";\nimport makeImagePass from \"./imagePass.js\";\nimport makeMirrorPass from \"./mirrorPass.js\";\nimport makeEndPass from \"./endPass.js\";\nimport { setupCamera, cameraCanvas, cameraAspectRatio, cameraSize } from \"../camera.js\";\n\nconst loadJS = (src) =>\n\tnew Promise((resolve, reject) => {\n\t\tconst tag = document.createElement(\"script\");\n\t\ttag.onload = resolve;\n\t\ttag.onerror = reject;\n\t\ttag.src = src;\n\t\tdocument.body.appendChild(tag);\n\t});\n\nconst effects = {\n\tnone: null,\n\tplain: makePalettePass,\n\tpalette: makePalettePass,\n\tcustomStripes: makeStripePass,\n\tstripes: makeStripePass,\n\tpride: makeStripePass,\n\ttransPride: makeStripePass,\n\ttrans: makeStripePass,\n\timage: makeImagePass,\n\tmirror: makeMirrorPass,\n};\n\nexport default async (canvas, config) => {\n\tawait loadJS(\"lib/gl-matrix.js\");\n\n\tif (document.fullscreenEnabled || document.webkitFullscreenEnabled) {\n\t\twindow.ondblclick = () => {\n\t\t\tif (document.fullscreenElement == null) {\n\t\t\t\tif (canvas.webkitRequestFullscreen != null) {\n\t\t\t\t\tcanvas.webkitRequestFullscreen();\n\t\t\t\t} else {\n\t\t\t\t\tcanvas.requestFullscreen();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdocument.exitFullscreen();\n\t\t\t}\n\t\t};\n\t}\n\n\tif (config.useCamera) {\n\t\tawait setupCamera();\n\t}\n\n\tconst canvasFormat = navigator.gpu.getPreferredCanvasFormat();\n\tconst adapter = await navigator.gpu.requestAdapter();\n\tconst device = await adapter.requestDevice();\n\tconst canvasContext = canvas.getContext(\"webgpu\");\n\n\t// console.table(device.limits);\n\n\tcanvasContext.configure({\n\t\tdevice,\n\t\tformat: canvasFormat,\n\t\talphaMode: \"opaque\",\n\t\tusage:\n\t\t\t// GPUTextureUsage.STORAGE_BINDING |\n\t\t\tGPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_DST,\n\t});\n\n\tconst timeUniforms = structs.from(`struct Time { seconds : f32, frames : i32, };`).Time;\n\tconst timeBuffer = makeUniformBuffer(device, timeUniforms);\n\tconst cameraTex = device.createTexture({\n\t\tsize: cameraSize,\n\t\tformat: \"rgba8unorm\",\n\t\tusage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,\n\t});\n\n\tconst context = {\n\t\tconfig,\n\t\tadapter,\n\t\tdevice,\n\t\tcanvasContext,\n\t\ttimeBuffer,\n\t\tcanvasFormat,\n\t\tcameraTex,\n\t\tcameraAspectRatio,\n\t\tcameraSize,\n\t};\n\n\tconst effectName = config.effect in effects ? config.effect : \"palette\";\n\tconst pipeline = await makePipeline(context, [makeRain, makeBloomPass, effects[effectName], makeEndPass]);\n\n\tconst targetFrameTimeMilliseconds = 1000 / config.fps;\n\tlet frames = 0;\n\tlet start = NaN;\n\tlet last = NaN;\n\tlet outputs;\n\n\tconst renderLoop = (now) => {\n\t\tif (isNaN(start)) {\n\t\t\tstart = now;\n\t\t}\n\n\t\tif (isNaN(last)) {\n\t\t\tlast = start;\n\t\t}\n\n\t\tconst shouldRender = config.fps >= 60 || now - last >= targetFrameTimeMilliseconds || config.once;\n\t\tif (shouldRender) {\n\t\t\twhile (now - targetFrameTimeMilliseconds > last) {\n\t\t\t\tlast += targetFrameTimeMilliseconds;\n\t\t\t}\n\t\t}\n\n\t\tconst devicePixelRatio = window.devicePixelRatio ?? 1;\n\t\tconst canvasWidth = Math.ceil(canvas.clientWidth * devicePixelRatio * config.resolution);\n\t\tconst canvasHeight = Math.ceil(canvas.clientHeight * devicePixelRatio * config.resolution);\n\t\tconst canvasSize = [canvasWidth, canvasHeight];\n\t\tif (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {\n\t\t\tcanvas.width = canvasWidth;\n\t\t\tcanvas.height = canvasHeight;\n\t\t\toutputs = pipeline.build(canvasSize);\n\t\t}\n\n\t\tif (config.useCamera) {\n\t\t\tdevice.queue.copyExternalImageToTexture({ source: cameraCanvas }, { texture: cameraTex }, cameraSize);\n\t\t}\n\n\t\tdevice.queue.writeBuffer(timeBuffer, 0, timeUniforms.toBuffer({ seconds: (now - start) / 1000, frames }));\n\t\tframes++;\n\n\t\tconst encoder = device.createCommandEncoder();\n\t\tpipeline.run(encoder, shouldRender);\n\t\t// Eventually, when WebGPU allows it, we'll remove the endPass and just copy from our pipeline's output to the canvas texture.\n\t\t// encoder.copyTextureToTexture({ texture: outputs?.primary }, { texture: canvasContext.getCurrentTexture() }, canvasSize);\n\t\tdevice.queue.submit([encoder.finish()]);\n\n\t\tif (!config.once) {\n\t\t\trequestAnimationFrame(renderLoop);\n\t\t}\n\t};\n\n\trequestAnimationFrame(renderLoop);\n};\n"],"names":["zero","array","n","simpleTypes","getTypeData","type","attributes","otherStructLayouts","align","size","baseType","defaultValue","innerLayout","makeDataForLayout","arrayMatch","_","innerType","fixedSize","elementTypeData","mult","stride","parseAttributes","str","attr","match","identifier","__","value","parseStructLayout","body","structLayouts","fields","byteOffset","lines","s","existingLines","line","index","lastLine","fieldMatch","leftAttributes","___","rightAttributes","typeData","minSizeInBytes","field","parseStructLayoutsFromShader","wgsl","structMatches","structMatch","layout","writeField","allLayouts","views","warnMissingFields","count","i","innerField","view","makeGenerator","minSize","object","destination","lastField","structs","loadTexture","device","url","data","source","texture","makeRenderTarget","format","mipLevelCount","makeComputeTarget","loadShader","code","makeUniformBuffer","uniforms","buffer","make1DTexture","rgbas","color","f","makeBindGroup","pipeline","entries","resource","binding","makePass","name","loaded","build","run","inputs","encoder","shouldRender","makePipeline","context","steps","step","canvasSize","outputs","rippleTypes","numVerticesPerQuad","makeConfigBuffer","configUniforms","config","density","gridSize","configData","makeRain","timeBuffer","mat4","vec3","assets","numCells","numQuads","transform","camera","renderFormat","linearSampler","renderPassConfig","configBuffer","sceneUniforms","sceneBuffer","introPipeline","computePipeline","renderPipeline","introBindGroup","computeBindGroup","renderBindGroup","output","highPassOutput","glyphMSDFTexture","glintMSDFTexture","baseTexture","glintTexture","rainShader","rainShaderUniforms","introCellsBuffer","cellsBuffer","additiveBlendComponent","aspectRatio","screenSize","introPass","computePass","renderPass","makePyramid","pyramidHeight","x","destroyPyramid","pyramid","makePyramidLevelView","level","makePyramidViews","tex","makeBloomPass","bloomSize","bloomStrength","bloomRadius","emptyTexture","blurPipeline","hBlurPyramid","vBlurPyramid","hBlurBuffer","vBlurBuffer","hBlurBindGroups","vBlurBindGroups","combinePipeline","combineBuffer","combineBindGroup","scaledScreenSize","blurShader","combineShader","blurUniforms","combineUniforms","srcView","hBlurPyramidView","vBlurPyramidView","dispatchSize","makePalette","paletteUniforms","paletteColors","sortedEntries","e1","e2","entry","colorToRGB","nextEntry","diff","ratio","paletteBuffer","makePalettePass","paletteShader","paletteShaderUniforms","transPrideStripeColors","prideStripeColors","makeStripePass","stripeColors","stripeTex","bloomTex","stripeShader","defaultBGURL","makeImagePass","bgURL","backgroundTex","bgTex","imageShader","start","numTouches","touches","touchesChanged","e","makeMirrorPass","cameraTex","cameraAspectRatio","touchUniforms","touchBuffer","mirrorShader","mirrorShaderUniforms","screenAspectRatio","makeEndPass","canvasFormat","canvasContext","nearestSampler","loadJS","src","resolve","reject","tag","effects","main","canvas","setupCamera","adapter","timeUniforms","cameraSize","effectName","targetFrameTimeMilliseconds","frames","last","renderLoop","now","devicePixelRatio","canvasWidth","canvasHeight","cameraCanvas"],"mappings":"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"}